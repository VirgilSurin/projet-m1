\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{listings-rust}
\usepackage{xcolor}
\usepackage{algorithm}
\usepackage{algpseudocode}
\edef\restoreparindent{\parindent=\the\parindent\relax}
\usepackage{parskip}
\restoreparindent
\usepackage{tikz}
\usetikzlibrary{arrows, automata}
\usepackage{subcaption}
\usepackage{graphicx}

\usepackage[export]{adjustbox}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=black,
    urlcolor=teal,
    pdftitle={Rapport de projet de master 1 - Virgil Surin},
    pdfauthor=Virgil Surin,
    pdfpagemode=FullScreen
}
\tikzset{every picture/.style={scale=1,auto=center,every node/.style={circle, draw=black!50,fill=blue!20}}}
\graphicspath{images/}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{blue},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

% \begin{titlepage}
%   \begin{center}

%     {\Large Université de Mons}\\[1ex]
%     {\Large Faculté des sciences}\\[1ex]
%     {\Large Département d'Informatique}\\[2.5cm]

%     \newcommand{\HRule}{\rule{\linewidth}{0.3mm}}
%     % Title
%     \HRule \\[0.3cm]
%     { \LARGE \bfseries Étude comparative d'algorithmes pour énumérer les cliques d'un graphe \\[0.3cm]}
%     % { \LARGE \bfseries Rapport préliminaire de projet de Master \\[0.1cm]} % Commenter si pas besoin
%     \HRule \\[1.5cm]

%     % Author and supervisor
%     \begin{minipage}[t]{0.45\textwidth}
%       \begin{flushleft} \large
%         \emph{Directeur:}\\
%         Hadrien \textsc{Mélot}\\
%         \emph{Co-directeur:}\\
%         Sébastien \textsc{Bonte}\\
%       \end{flushleft}
%     \end{minipage}
%     \begin{minipage}[t]{0.45\textwidth}
%       \begin{flushright} \large
%         \emph{Auteur:} \\
%         Virgil \textsc{Surin}
%       \end{flushright}
%     \end{minipage}\\[2ex]

%     \vfill

%     % Bottom of the page
%     \begin{center}
%       \begin{tabular}[t]{c c c}
%         \includegraphics[height=1.5cm]{logoumons.jpg} &
%                                                         \hspace{0.3cm} &
%                                                                          \includegraphics[height=1.5cm]{logofs.jpg}
%       \end{tabular}
%     \end{center}~\\

%     {\large Année académique 2023-2024}

%   \end{center}
% \end{titlepage}
\begin{titlepage}
  \begin{center}
    \textnormal{\Large{Universit\'e de Mons}}\\[0.3em]
    \textnormal{\Large{Facult\'e des Sciences}}\\[0.3em]
  \end{center}
  \vspace*{3cm}
  \begin{center}
    \fbox{
      \begin{minipage}{0.9\textwidth}
        \centering
        \vspace*{0.5cm}\textbf{\LARGE{Étude comparative d'algorithmes\\}}
        \textbf{\LARGE{d'énumération de cliques d'un graphe }}\vspace*{0.5cm}
      \end{minipage}
    }
  \end{center}
  \vspace*{2cm}

  \begin{minipage}[t]{0.45\textwidth}
    \begin{flushleft} \large
      \emph{Directeur:}\\
      Hadrien \textsc{Mélot}\\
      \emph{Co-directeur:}\\
      Sébastien \textsc{Bonte}\\
    \end{flushleft}
  \end{minipage}
  \begin{minipage}[t]{0.45\textwidth}
    \begin{flushright} \large
      \emph{Auteur:} \\
      Virgil \textsc{Surin} \\
    \end{flushright}
  \end{minipage}\\[2ex]

  \vspace*{2cm}
  \begin{center}
    \includegraphics[height=1.7cm]{images/logoumons.jpg}
    \hspace{1cm}
    \includegraphics[height=1.7cm]{images/logofs.jpg}
    \\[1em]
    Ann\'ee acad\'emique 2023-2024
  \end{center}

\end{titlepage}

\tableofcontents

\newpage

\section{Introduction}


Dans ce rapport nous allons étudier plusieurs algorithmes d'énumeration de cliques maximales dans un graphe simple non orienté. Cette étude se base principalement sur l'article d'Alessio Conte et Etsuji Tomita  \textit{''On the overall and delay complexity of the CLIQUES and Bron-Kerbosch algorithms''} \cite{CONTE20221}.

L'objectif de ce projet est d'implémenter les algorithmes présentés et de confirmer les résultats obtenus par M.Conte et M.Tomita. Également, ces algorithmes seront implémentés en Python et en Rust afin de valider le gain de temps de Rust par rapport à Python.

Nous commencerons par un rappel des notions et notations utilisées ainsi que des définitions utiles à la compréhension de ce rapport, suivi d'une présentation des différents algorithmes implémentés et pour terminer par la comparaison d'efficacité en temps et en langage de ceux-ci.


\section{État de l'art}%
\label{sec:etat}
Les premiers travaux sur ce sujet remontent aux années 1970 avec l'algorithme de Bron-Kerbosch\cite{bron1973algorithm}, qui demeure l'une des méthodes les plus utilisées. Cet algorithme est basé sur une approche récursive en profondeur (\textit{depth-first search}) et fonctionne sans générer de doublons, ce qui en fait une solution efficace malgré sa complexité exponentielle dans le pire des cas .

En 1977, Tsukiyama et al. ont proposé un algorithme \emph{output-sensitive} pour énumérer les cliques maximales \cite{tsukiyama1977new}. Cet algorithme garantit que le temps entre la sortie de deux cliques consécutives est borné par une fonction polynomiale de la taille de l'entrée. Un autre développement significatif est l'algorithme CLIQUES, introduit par Tomita et al., qui utilise une stratégie de recherche en profondeur et produit les cliques maximales sous forme d'arbre. Cet algorithme atteint une complexité temporelle optimale dans le pire des cas de \(O(3^{n/3})\) et est l'algorithme que nous allons comparé à celui de Bron et Kerbosch.

La technique de recherche inversée introduite par Avis et Fukuda a été adaptée pour l'énumération des cliques maximales \cite{avis1996reverse}. Des améliorations successives par des chercheurs comme Chiba et Nishizeki \cite{chiba1985arboricity}, et Makino et Uno \cite{makino2004new}, ont permis d'améliorer l'efficacité et la scalabilité, notamment dans les graphes clairsemés, dits \emph{sparse graph}. Des travaux récents de Conte et collègues ont fourni de nouvelles perspectives sur la complexité globale et la complexité de délai des algorithmes d'énumération des cliques, démontrant que les algorithmes basés sur CLIQUES et Bron-Kerbosch sont performants en pratique sur des graphes du monde réel \cite{conte2022overall}.

\section{Les cliques, cas d'utilisations}%
\label{sec:usecase}

Étudier le problème d'énumération de cliques maximales et développer des algorithmes efficaces pour ce faire présente un intérêt considérable en raison de la multitude de systèmes qui peuvent être modélisés par des graphes. Dans de nombreux contextes, des amats de sommets tous connectés entre eux, connus sous le nom de cliques, apparaissent naturellement. Ces cliques peuvent représenter des compartiments indépendants ou des unités logiques au sein du système étudié.

Les applications des cliques sont variées et couvrent de nombreux domaines. En biologie, par exemple, les cliques peuvent représenter des complexes protéiques où chaque protéine interagit avec toutes les autres du complexe, fournissant ainsi des informations cruciales pour comprendre les réseaux de signalisation cellulaire et les interactions protéine-protéine \cite{PAVLOU2016305}.

Dans le domaine de la sociologie, les cliques sont utilisées pour identifier des groupes d'individus ayant des interactions fréquentes et intenses, ce qui peut aider à analyser les structures sociales et les dynamiques de groupe \cite{SCOTT201129}.

En informatique, les cliques peuvent être utilisées dans l'optimisation des requêtes de bases de données et dans la détection de communautés au sein des réseaux de communication \cite{CORMEN200932}.

En résumé, la capacité à identifier efficacement les cliques dans un graphe a des applications concrètes, allant de la compréhension des systèmes biologiques complexes à l'analyse des structures sociales en passant par l'optimisation des systèmes informatiques. Ces exemples illustrent l'importance pratique des cliques dans la recherche et les applications réelles\cite{FORTUNATO201075}.

\section{Les graphes}%
\label{sec:graphes}

\subsection{Notions de bases}

Dans ce rapport, nous allons définir un graphe simple non orienté \emph{G=V, E} comme étant un ensemble de nœuds \emph{V} reliés par des arêtes. Nous notons l'ensemble des arêtes comme étant l'ensemble \emph{E}. Une arêtes est définie comme un tuple $ (v, v') $ où $ v $ et $ v' $ sont les 2 nœuds réliés par l'arête. Les nœuds peuvent être étiquetés pour plus de lisibilité.


Nous considérons des graphes simples non dirigés, c'est à dire qu'il y a au plus une et une seule arête entre deux nœuds et aucune arête allant d'un nœud à lui-même. Les arêtes que nous considérons n'ont pas de sens particulier. Ainsi, l'arête joignant les nœuds \emph{x} et \emph{y} est la même que celle joignant \emph{y} à \emph{x} et sera dénotée par l'existence du tuple $(x, y) \in E$.

L'ordre \emph{n} d'un graphe est défini comme étant $ |V| $ et sa taille \emph{m} comme $ |E| $.

Dans la Figure \ref{fig:x exemple1}, nous pouvons observer un premier graphe \textit{a} dont l'ensemble des noeuds \(V\) est l'ensemble \(\{1, 2, 3\}\). L'ensemle des arretes \(E\) quant a lui est l'ensemble \(\{(1,2), (2,3)\}\). Le graphe \textit{a} est un graphe d'ordre 3 et de taille 2. De la meme facon, pour le graphe \textit{b} on a \(V = \{1, 2, 3, 4, 5\}\) et \(E = \{(1,2), (2,3), (4,5)\}\). \textit{b} est d'ordre 5 et de taille 3.

\begin{figure}[h]
  \begin{subfigure}[b]{0.50\textwidth}
    \centering
        \begin{tikzpicture}

          \node (v1) at (0, 0){1};
          \node (v2) at (0, 2){2};
          \node (v3) at (2, 2){3};

          \draw[-](v1)--(v2);
          \draw[-](v2)--(v3);

        \end{tikzpicture}
        \caption{}
        \label{fig:x g1}
  \end{subfigure}
  \begin{subfigure}[b]{0.50\textwidth}
    \centering
        \begin{tikzpicture}

          \node (v1) at (0, 0){1};
          \node (v2) at (1, 2){2};
          \node (v3) at (3, 2){3};
          \node (v4) at (2, 0){4};
          \node (v5) at (4, 1){5};

          \draw[-](v1)--(v2);
          \draw[-](v2)--(v3);
          \draw[-](v4)--(v5);
        \end{tikzpicture}
        \caption{}
        \label{fig:x g2}
  \end{subfigure}
  \caption{Deux graphes}
  \label{fig:x exemple1}
\end{figure}

Soit \emph{G=V, E} Nous définirons les voisins d'un noeud \emph{v} comme l'ensemble des noeuds directement relié à \emph{v} par une arrete. Nous noterons l'ensemble des voisins de \emph{v} comme \emph{N(v)} définit formellement comme suit:
\begin{equation}
N(v) = { v' | (v, v') \in E }
\end{equation}
Prenons le noeud \emph{2} du graphe \emph{b} de la Figure \ref{fig:x exemple1}. L'ensemble des voisins de ce noeud est l'ensemble \(N = {1, 3}\).


Soit \emph{G = V, E}, un sous-graphe induit de \emph{G}, noté \(SG = W, E(W)\), est un graphe construit à partir d'un sous-ensemble de noeud de \emph{V} où $ W \subseteq V $ et $ E(W) = E \cap (W \times W) $. Nous appellons \emph{SG=W, E(W)}..
Notez que dans un sous-graphe induit, nous ne conservons pas les arrêtes dont une extrémité ne se trouve pas dans \emph{W}.

Par exemple, en prenant le graphe \textit{b} de la Figure \ref{fig:x exemple1}, le sous-graphe \(SG=\{1, 2, 5\}, E(\{1, 2, 5\})\) est un sous-graphe valide de \textit{b} contenant uniquement les noeuds 1, 2 et 5 (\(W\)) et l'arrete \((1,2)\) (\(E(W)\)).

\begin{figure}
  \centering
  \begin{tikzpicture}

    \node (v1) at (0, 0){1};
    \node (v2) at (1, 2){2};
    \node (v5) at (4, 1){5};

    \draw[-](v1)--(v2);

  \end{tikzpicture}
  \caption{un sous-graphe de \textit{b}}
\end{figure}

\subsection{Les cliques}%
\label{subsec:cliques}

Une \textit{clique} est définie comme suit :
soit un graphe \emph{G=V,E}. Nous dirons que \(C \subseteq V\), un sous-ensemble de noeuds du graphe, est une clique si et seulement si tous les noeuds de \emph{C} sont voisins entre-eux.
C'est-à-dire :
\begin{equation}\label{clique}
\forall v, w \in C \ | \ (v, w)\in E \ avec\  v \neq w
\end{equation}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}

    \node[fill=red!20](v1) at (0, 0){1};
    \node[fill=red!20](v2) at (0, 2){2};
    \node[fill=red!20](v3) at (2, 2){3};
    \node[fill=red!20](v4) at (3, 0){4};
    \node (v5) at (4, 2){5};
    \node (v6) at (6, 1.5){6};
    \node (v7) at (5, 0){7};

    \draw[red!20, ultra thick](v1)--(v2);
    \draw[red!20, ultra thick](v2)--(v3);
    \draw[red!20, ultra thick](v1)--(v3);
    \draw[red!20, ultra thick](v1)--(v4);
    \draw[red!20, ultra thick](v2)--(v4);
    \draw[red!20, ultra thick](v3)--(v4);
    \draw[-](v3)--(v5);
    \draw[-](v4)--(v5);
    \draw[-](v5)--(v6);
    \draw[-](v4)--(v6);
    \draw[-](v4)--(v7);
    \draw[-](v6)--(v7);
  \end{tikzpicture}
  \caption{Un graphe, en rouge une clique de ce graphe}
  \label{fig:x clique1}
\end{figure}

Il est important de remarquer qu'avec cette définition d'une clique, un noeud seul n'est pas une clique.

La \textit{taille} d'une clique est définie par sa cardinalité, c'est à dire que la taille d'une clique \emph{C} est \(|C|\). Comme exemple, prenons la clique en rouge dans le graphe de la Figure \ref{fig:x clique1} : nous avons que \(C = \{1,2,3,4\}\) et \(|C| = 4\). C'est donc une clique de taille 4.

Nous dirons qu'une clique est \textit{maximale} s'il est impossible de rajouter un nœuds de \emph{G} dans la clique tel que la propriété \eqref{clique} reste respectée.

Dans la Figure \ref{fig:x clique1}, la clique \textit{bleue} composée des noeuds 1, 2, 3 et 4 est egalement maximale. Par contre, la clique composée des noeuds 3 et 5 ne l'est pas car il est possible d'y rajouter le noeud 4.

Enfin, nous définirons une clique \textit{maximum} comme étant une clique de taille maximum. Notons que toute clique maximum sera maximale et qu'il peut y avoir plusieurs cliques maximum dans un même graphe.

\begin{figure}[h]
  \begin{center}
\begin{tikzpicture}

  \node (v1) at (0, 0){1};
  \node (v2) at (0, 2){2};
  \node[fill=red!20](v3) at (2, 2){3};
  \node[fill=red!20](v4) at (3, 0){4};
  \node[fill=red!20](v5) at (4, 2){5};
  \node (v6) at (6, 1){6};
  
  \draw[-](v1)--(v2);
  \draw[-](v2)--(v3);
  \draw[red!20, ultra thick](v3)--(v4);
  \draw[red!20, ultra thick](v3)--(v5);
  \draw[red!20, ultra thick](v4)--(v5);
  \draw[-](v5)--(v6);
\end{tikzpicture}
\caption{Un graphe}
  \label{fig:x clique2}
\end{center}
\end{figure}

Regardons la Figure \ref{fig:x clique2}. $ \{3, 4, 5\}$ (en rouge) est une clique maximale et maximum car il n'est pas possible de rajouter un noeud à cette clique tel qu'il sera voisin de 3, 4 et 5 (maximale) et il n'existe pas de clique de plus grande taille (maximum). Par contre, la clique composée des noéuds 1 et 2, bien qu'étant maximale (en effet, aucun autre noeud du graphe ne peut être ajouté à cette clique) n'est pas maximum car elle ne contient que 2 noeuds là où la clique précédemment mentionnée (celle en rouge sur la figure \ref{fig:x clique2}) est plus grande vu qu'elle contient 3 noeuds.

\subsection{Quelques types de graphes}%
\label{subsec:graphes}

\subsubsection*{Graphe complet}
\label{subsubsec:complet}

Un graphe complet d'ordre \emph{n} est un graphe avec le maximum d'arrêtes possibles, c'est à dire \(\frac{n(n-1)}{2}\) arrêtes. Dans un graphe complet, chaque noeud est directement connectés à chaque noeuds, autrement dit, le graphe \(G = V, E\) est complet si et seulement si on a :
\begin{equation}
\forall (v,w) \in V \ | \ (v, w) \in E \ \text{avec} \ v \neq w
\end{equation}

La Figure \ref{fig:k6} représente un graphe complet d'ordre 6.

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        % Define the positions of the nodes
        \node (n1) at (0, 0) {1};
        \node (n2) at (3, 0) {2};
        \node (n3) at (-2, 2) {3};
        \node (n4) at (5, 2) {4};
        \node (n5) at (0, 4) {5};
        \node (n6) at (3, 4) {6};

        % Draw the edges
        \foreach \from/\to in {
          n1/n2, n1/n3, n1/n4, n1/n5, n1/n6,
          n2/n3, n2/n4, n2/n5, n2/n6,
          n3/n4, n3/n5, n3/n6,
          n4/n5, n4/n6,
          n5/n6} \draw (\from) -- (\to);
    \end{tikzpicture}
    \caption{Graphe complet d'ordre 6}
    \label{fig:k6}
\end{figure}

Il est évident qu'un graphe complet contient une et une seule clique maximale (qui est donc également maximum) et que celle-ci est de taille \emph{n}. Il s'agit de l'ensemble du graphe.

\subsubsection*{Graphe vide}
\label{subsubsec:vide}

Un graphe vide d'ordre \emph{n} est un graphe ne possédant aucune arrête. C'est-à-dire dont la taille \emph{m} est égale à 0. Un exemple de graphe vide d'ordre 4 est donné ci-dessous (Figure \ref{fig:vide}).
Naturellement, un graphe vide d'ordre \emph{n} possède \emph{n} cliques maximales de tailles 1 et elles sont toutes maximum.

\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \node (n1) at (0, 0) {1};
    \node (n2) at (2, 0) {2};
    \node (n3) at (0, 2) {3};
    \node (n4) at (2, 2) {4};

  \end{tikzpicture}
  \caption{Graphe vide d'ordre 4}
  \label{fig:vide}
\end{figure}

\subsubsection*{Graphe de Turàn}
\label{subsubsec:turan}

Un graphe de Turán, noté \( T(n, r) \), est un graphe formé en partitionnant un ensemble de \( n \) sommets en \( r \) sous-ensembles aussi égaux que possible, et en connectant deux sommets par une arête si et seulement s'ils appartiennent à des sous-ensembles différents. Les graphes de Turán sont souvent utilisés dans la théorie des graphes extrémaux car ils maximisent le nombre d'arêtes sans contenir un certain sous-graphe interdit, comme un \( K_{r+1} \) (le graphe complet sur \( r+1 \) sommets).

Formellement, le graphe de Turán \( T(n, r) \) est défini comme suit :
\begin{itemize}
  \item Partitionner les \( n \) sommets en \( r \) sous-ensembles \( V_1, V_2, \ldots, V_r \) aussi égaux que possible.
  \item Ajouter une arête entre deux sommets \( u \) et \( v \) si et seulement s'ils appartiennent à des sous-ensembles différents, c'est-à-dire \( u \in V_i \) et \( v \in V_j \) avec \( i \neq j \).
\end{itemize}

Considérons \( T(9, 3) \) (Figure \ref{fig:turan}). Nous partitionnons les 9 sommets en 3 sous-ensembles de 3 sommets chacun. Les arêtes connectent les sommets de sous-ensembles différents.

\begin{figure}[h!]
  \centering
  \begin{tikzpicture}

    \node[fill=green!50] (n1) at (0, 0) {1};
    \node[fill=green!50] (n2) at (2, 0) {2};
    \node[fill=green!50] (n3) at (4, 0) {3};

    \node[fill=blue!50] (n4) at (-2, 1) {4};
    \node[fill=blue!50] (n5) at (-2, 3) {5};
    \node[fill=blue!50] (n6) at (-2, 5) {6};

    \node[fill=red!50] (n7) at (0, 6) {7};
    \node[fill=red!50] (n8) at (2, 6) {8};
    \node[fill=red!50] (n9) at (4, 6) {9};

    \foreach \from/\to in {
      n1/n4, n1/n5, n1/n6, n1/n7, n1/n8, n1/n9,
      n2/n4, n2/n5, n2/n6, n2/n7, n2/n8, n2/n9,
      n3/n4, n3/n5, n3/n6, n3/n7, n3/n8, n3/n9,
      n4/n7, n4/n8, n4/n9,
      n5/n7, n5/n8, n5/n9,
      n6/n7, n6/n8, n6/n9} \draw (\from) -- (\to);
  \end{tikzpicture}
  \caption{Graphe de Turán \( T(9, 3) \)}
  \label{fig:turan}
\end{figure}

Dans cet exemple, les sommets \{1, 2, 3\}, \{4, 5, 6\}, et \{7, 8, 9\} forment les trois sous-ensembles. Chaque sommet est connecté à tous les sommets des autres sous-ensembles, mais il n'y a pas d'arêtes entre les sommets d'un même sous-ensemble.

\subsubsection*{Graphes de Moon-Moser}
\label{subsubsec:mm}

Les graphes de Moon-Moser sont un sous-ensemble particulier de graphes de Turán. Un graphe de Moon-Moser est un graphe \( T(n, \lceil n/3 \rceil) \).

Considérons un graphe de Moon-Moser avec 6 sommets, c'est-à-dire \( T(6, 2) \). Nous avons deux sous-ensembles de trois sommets chacun, et chaque sommet est connecté à tous les sommets des autres sous-ensembles.

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        \node (n1) at (0, 0) {1};
        \node (n2) at (3, 0) {2};
        \node (n3) at (6, 0) {3};
        \node (n4) at (0, 3) {4};
        \node (n5) at (3, 3) {5};
        \node (n6) at (6, 3) {6};

        \foreach \from/\to in {
          n1/n4, n1/n5, n1/n6,
          n2/n4, n2/n5, n2/n6,
          n3/n4, n3/n5, n3/n6}
        \draw (\from) -- (\to);
    \end{tikzpicture}
    \caption{Graphe de Moon-Moser d'ordre 6}
    \label{fig:moon-moser}
\end{figure}

Dans cet exemple, les deux sous-ensembles sont \{1, 2, 3\} et \{4, 5, 6\}. Chaque sommet est connecté à tous les sommets de l'autre sous-ensemble.

Les graphes de Moon-Moser maximisent le nombre de cliques maximales dans un graphe \cite{MR0182577}.

\section{Le problème d'énumération des cliques dans un graphe}

\subsection{Définition}%
\label{subsec:def_prob}

Ce problème consiste, dans un graphe simple, à énumérer toutes les cliques \textbf{maximales} de celui-ci. L'ordre dans lequel celles-ci sont listées n'est pas important.

\begin{figure}[h]
  \begin{center}
    \begin{tikzpicture}

      \node (v1) at (0, 1){1};
      \node (v2) at (0, 3){2};
      \node (v3) at (2, 2){3};
      \node (v4) at (4, 0){4};
      \node (v5) at (4, 2){5};
      \node (v6) at (6, 3){6};
      \node (v7) at (6, 1){7};

      \draw[-](v1)--(v2);
      \draw[-](v1)--(v3);
      \draw[-](v2)--(v3);
      \draw[-](v3)--(v4);
      \draw[-](v3)--(v5);
      \draw[-](v4)--(v5);
      \draw[-](v5)--(v6);
      \draw[-](v5)--(v7);
      \draw[-](v4)--(v7);
      \draw[-](v4)--(v6);
      \draw[-](v6)--(v7);
    \end{tikzpicture}
    \caption{}
    \label{fig:x clique3}
  \end{center}
\end{figure}


Prenons par exemple le graphe en Figure \ref{fig:x clique3}. Nous sommes donc intéressé d'obtenir les cliques suivantes :
\begin{itemize}
        \item \(\{1, 2, 3\}\)
        \item \(\{5, 4, 3\}\)
        \item \(\{4, 5, 7, 6\}\)
\end{itemize}
Ces trois cliques sont bien les seules et uniques cliques maximales de ce graphe. De plus, la clique maximum est celles contenant les noeuds 4, 5, 6 et 7.
Notez comme la clique \({4, 5, 6}\) n'est pas reprise, en effet celle-ci n'est pas maximale car elle peut être agrandie avec le noeud 7.

\subsection{Complexité du problème}
L'énumération des cliques maximales dans un graphe simple est un problème fondamental en théorie des graphes et en informatique théorique. Ce problème consiste à identifier toutes les cliques maximales d'un graphe, c'est-à-dire les sous-graphes complets qui ne peuvent être étendus par l'ajout d'un sommet adjacent. Bien que ce problème ne soit pas un problème \(\mathcal{N}\mathcal{P}\text{-Difficile}\), il reste un problème qui pose des défis important et qui ne peut actuellement ètre résolu en temps polynomial.

En effet, les meilleurs algorithmes que nous connaissons permettent d'énumérer toutes les cliques maximales d'un graphe sont polynomial en le nombre de cliques maximales. Or, nombre de cliques maximales dans un graphe peut être exponentiel par rapport au nombre de sommets du graphe. En effet, Moon et Moser ont démontré qu'un graphe simple à \(n\) noeuds a au plus \( 3^{n/3} \) cliques maximales\cite{MR0182577}. D'ailleurs, les graphes qui maximise le nombre de cliques maximales sont nommés graphe de Moon-Moser (voir section \ref{subsubsec:mm}).

Nous allons ici présenter un algorithme (et des variantes) qui atteint une complexité dans le pire des cas de \(O(3^{3/n})\)\cite{CONTE20221}, correspondant ainsi au nombre de cliques qu'il faut énumérer (dans le pire des cas). Même si ce résultat semble décevant, il signifie surtout que nous pouvons énumérer toutes les cliques en temps polynomial par rapport au nombre de cliques dans le graphe. Cela implique que le délai pour trouver la prochaine clique est également polynomial. En pratique, cet algorithme et ces variantes se comportent plutôt bien en terme de temps.

\section{Idée générale}%
\label{sec:idee}

\subsection{Explication}%
\label{subsec:explication}

Dans cette section nous allons aborder et expliquer l'idée générale commune à chacun des algorithmes présentés dans les sections \ref{sec:clique} et \ref{sec:bk1}.

Rappellons que l'objectif de ces algorithmes est d'énumérer toutes les cliques maximales dans un graphe \emph{G = (V, E)}.

L'idée est de passer par une recherche en profondeur. L'algorithme commence avec un ensemble de tous les sommets du graphe et explore récursivement toutes les combinaisons possibles de sommets pour former des cliques en appliquant des techniques d'élagages afin de ne pas considérer de duplicata.

Pour ce faire, notre procédure défini trois ensembles de sommets :
\begin{itemize}
  \item \emph{Q}, la clique en train d'être énumérée
  \item \texttt{SUBG}, qui représente les sommets restants à explorer (notez que \texttt{SUBG} est un sous-graphe induit de \emph{G}).
  \item \texttt{CAND}, qui contient les sommets qui peuvent être ajoutés à \emph{Q} (les candidats). \texttt{CAND} est entièrement contenue dans \texttt{SUBG}.
\end{itemize}
À chaque étape de la recherche, un sommet \emph{p} est sélectionné et ajouté à \emph{Q}.  Ensuite, nous réduisons \texttt{SUBG} à \texttt{SUBG} \(\cap\) \emph{N(p)} et \texttt{CAND} à \texttt{CAND} \(\cap\) \emph{N(p)}. Lorsque nous remontons dans la recherches (backtracking), nous retirons \emph{p} des \texttt{CAND}idats mais pas de \texttt{SUBG}. Ainsi les cliques contenues dans \texttt{CAND} n'auront pas de doublons (vu que nous ne cherchons que les maximales, lorsque nous trouvons une clique maximale avec \emph{p} il n'est pas nécessaire de chercher une autre clique maximale contenant \emph{p} car elles ont déjà toutes été trouvées lors de l'exploration des cliques contenant \emph{p})

Lorsque \texttt{SUBG} est vide, cela veut dire que nous avons trouvé une clique maximale car il n'y a plus de sommet à explorer.

\subsection{Le pivotage}%
\label{subsec:pivotage}


Afin d'optimiser la recherche en profondeur nous choisissons, avant de choisir un sommet \emph{p}, un noeud pivot \emph{u} qui permettra d'élaguer la recherche. Car chaque clique maximale \emph{Q'} dans \texttt{SUBG} \(\cap\) \emph{N(u)} n'est en réalité pas maximale dans \texttt{SUBG} vu que \emph{Q'} \(\cup \{u\}\) est une clique plus grande dans \texttt{SUBG}. Ainsi nous pouvons couper l'exploration de tous les sommets dans \emph{N(u)}.


La stratégie de pivot est une technique utilisée pour réduire le nombre de récursions nécessaires en sélectionnant un sommet pivot et en explorant ses voisins. Voici comment cette stratégie fonctionne :

L'algorithme commence par sélectionner un pivot, noté \( u \), dans \texttt{SUBG}. Nous discuterons de plusieurs stratégies pour choisir ce pivot plus tard.

Une clique maximale \( Q' \) dans \(\texttt{SUBG} \cap N(u)\) n'est pas maximale dans \( \texttt{SUBG} \), car \( Q' \cup \{u\} \) est une clique plus grande dans \( \texttt{SUBG} \) étant donné que tous les sommets de \(Q'\) sont voisins de \emph{u}. Ainsi, toute clique maximale contient soit \( u \), soit au moins un sommet de \( \texttt{SUBG} \setminus N(u) \). Cela signifie que nous pouvons ignorer l'expansion de tous les sommets dans \( N(u) \) et n'explorer que ceux dans \( \texttt{SUBG} \setminus N(u) \).

Voici un exemple détaillé.

\begin{figure}[h!]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \begin{tikzpicture}
            \node (n1) at (0, 0) {1};
            \node (n2) at (0, 2) {2};
            \node (n3) at (2, 2) {3};
            \node (n4) at (3, 0) {4};
            \node (n5) at (4, 2) {5};
            \node (n6) at (4, 0) {6};
            \node (n7) at (5, 1) {7};

            \foreach \from/\to in {n1/n2, n2/n3, n1/n3, n1/n4, n3/n4, n3/n5, n4/n5, n4/n6, n5/n6, n5/n7}
              \draw (\from) -- (\to);
        \end{tikzpicture}
        \caption{SUBG}
        \label{fig:initial}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \begin{tikzpicture}
            \node (n1) at (0, 0) {1};
            \node (n2) at (0, 2) {2};
            \node (n3) at (2, 2) {3};
            \node (n4) at (3, 0) {4};
            \node (n5) at (4, 2) {5};
            \node (n6) at (4, 0) {6};
            \node (n7) at (5, 1) {7};

            \foreach \from/\to in {n1/n2, n2/n3}
              \draw[red!20, ultra thick] (\from) -- (\to);
            \foreach \from/\to in {n3/n5, n4/n5, n1/n3, n1/n4, n3/n4, n5/n6, n4/n6, n5/n7}
              \draw (\from) -- (\to);
            \node[fill=red!20] at (0, 2) {2};
        \end{tikzpicture}
        \caption{Sélection du pivot (2)}
        \label{fig:pivot}
    \end{subfigure}
    \vfill
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \begin{tikzpicture}
            \node (n4) at (0, 0) {4};
            \node (n5) at (1, 2) {5};
            \node (n6) at (1, 0) {6};
            \node (n7) at (2, 1) {7};
            \foreach \from/\to in {n4/n5, n5/n6, n4/n6, n5/n7}
              \draw (\from) -- (\to);
        \end{tikzpicture}
        \caption{\(\texttt{SUBG} \backslash N(u)\) }
        \label{fig:subgraph1}
    \end{subfigure}
    \caption{Étapes de l'algorithme d'énumération des cliques maximales avec pivot}
    \label{fig:cliques_algorithm}
\end{figure}

L'algorithme commence par sélectionner un pivot. Supposons que nous choisissons le sommet 2.
Clairement, toute clique maximale dans \(\texttt{SUBG} \cap N(u)\) ne sera pas maximale si l'on tient en compte le noeud \emph{u}.

L'utilisation d'un pivot est cruciale car elle permet de réduire le nombre d'appel récursif.

\subsection{Pseudo-code commun}%
\label{subsec:algo}

Ci-dessous ce trouve le pseudo code générique des différents algorithmes que nous présentons. Il s'agit là de leur squelette commun. La partie sur le choix du pivot est volontairement laissée floue et sera précisée dans les sous-sections respectives de chacun des algorithmes.

\begin{algorithm}[H]
  \textbf{Input}: un graphe $G = (V,E)$

  \textbf{Output}: toutes les cliques maximales de $G$
  \begin{algorithmic}[1]
    \Procedure{ALG}{$SUBG, CAND$}
      \If{$SUBG = \emptyset$} \Comment{$Q$ est une clique maximale}
        \State \textbf{print} ($ Q $)
      \Else
        \State $u \gets$ un noeud pivot de \emph{SUBG}
        \While{ il reste des noeuds candidats}
          \State $p \gets$ un noeud dans $CAND \setminus N(u)$
          \State $ Q \cup p $ \Comment{on ajoute \emph{p} à $Q$}
          \State // Mise à jour des paramètres
          \State $SUBG_p \gets SUBG \cap N(p)$
          \State $CAND_p \gets CAND \cap N(p)$
          \State \Call{ALG}{$SUBG_p, CAND_p$}
          \State $CAND \gets CAND \setminus {p}$
          \State $ Q \setminus p $ \Comment{on retire \emph{p} de $Q$}
        \EndWhile
      \EndIf
    \EndProcedure
    \State \Call{ALG}{$V,V$}
  \end{algorithmic}
  \caption{Squelette de base}
  \label{fig:alg}
\end{algorithm}

La condition en ligne 2 permet de savoir si nous avons trouvé une clique maximale ou non, en effet, si \emph{SUBG} est vide, alors nous sommes arrivés au bout de notre exploration en profondeur et donc la clique \emph{Q} est maximale, il ne reste plus de noeud candidat qui pourrait étendre celle-ci.

Dans le cas contraire, nous choississons un pivot \emph{u} (ligne 5) en fonction d'une stratégie (définit pour chaque algorithmes, ici abstraite). Ensuite tant que nous avons des candidats, nous allons prendre un noeud \emph{p} qui ne fait pas partie des voisins de notre pivot \emph{u} (ligne 7) et l'ajouter à notre clique courante \emph{Q}. Ensuite, nous ajustons les ensembles \emph{SUBG} et \texttt{CAND} pour faire un appel récursif et explorer en profondeur la clique donnée par \(Q \cup \{p\}\) (lignes 10-2).
Lors du backtracking, il ne faut pas oublier de retirer \emph{p} de \texttt{CAND} et de \emph{Q} afin de pouvoir explorer d'autres candidats et possiblités.

Les sections suivantes (\ref{sec:clique} et \ref{sec:bk1}) vont présenter les spécificité de chaque algorithmes. Pour rappel, ils se différencient dans le choix du noeud pivot.

\section{Bron-Kerbosch}%
\label{sec:bk1}

L'algorithme de Bron-Kerbosch est l'algorithme sur lequel se base l'algorithme \texttt{CLIQUE} ainsi ses variantes. Nous présenterons ici une version sans pivot, basique, de cet algorithme ainsi que deux version avec pivots.

\subsection{Sans pivot}%
\label{subsec:bk}
Cette version sans pivot est identique à l'algorithme \ref{fig:alg} si ce n'est qu'il n'y a pas de pivot qui est choisi. Dans ce cas, la boucle \texttt{while} va donc itérer sur tout les noeuds de \texttt{CAND}, c'est-à-dire, les noeuds candidats pour la clique courante.

\subsection{Pivot aléatoire}%
\label{subsec:random}
Une version avec un pivot choisi aléatoirement est proposée. Un noeud \emph{u} est donc choisi parmi les noeuds de \texttt{SUBG}. Ensuite, l'ensemble des noeuds candidats est réduit à \(\texttt{CAND} \setminus N(u)\) conformément à ce qui est décrit dans la section sur le pivotage \ref{subsec:pivotage}.

\subsection{Pivot de degré maximum}%
\label{subsec:max}
La dernière variante présentée ici de l'algorithme de Bron-Kerbosch utilise comme stratégie de pivotage le choix d'un noeud de \texttt{SUBG} de degré maximum (notez que ce noeud n'est pas unique, dans ce cas, un des noeuds de degré maximum est choisi au hasard). De même que pour \ref{subsec:random}, l'ensemble des noeuds candidats devient alors \(\texttt{CAND} \setminus N(u)\).


\section{CLIQUE}
\label{sec:clique}
La Figure \ref{fig:cliques} montre le pseudo-code de l'algorithme \texttt{CLIQUE}, dérivé de l'algorithme présenté dans la section \ref{subsec:algo}.

Comme dit précédemment, la différence principale se trouve dans le choix du pivot. Ici, un bon pivot est décrit comme un noeud \emph{u} de \texttt{SUBG} qui maximise $ | \texttt{CAND} \cap N(u) |$. Un tel pivot va donc minimiser $ |\texttt{CAND} \setminus N(u)| $, ce qui est intéressant car comme énoncé dans la section \ref{fig:pivot}, nous allons choisir des candidats parmi les noeuds de $ |\texttt{CAND} \setminus N(u)| $. Un tel pivot va donc minimiser le nombre d'appel récursif, permettant d'atteindre une complexité, pour \texttt{CLIQUE}, en $ O(3^{n/3}) $\cite{CONTE20221}.

\begin{algorithm}[H]
  \textbf{Input}: un graphe $G = (V,E)$

  \textbf{Output}: toutes les cliques maximales de $G$
  \begin{algorithmic}[1]
    \Procedure{CLIQUES}{$SUBG, CAND$}
      \If{$SUBG = \emptyset$} \Comment{$Q$ est une clique maximale}
        \State \textbf{print} ($ Q $)
      \Else
        \State $u \gets$ un noeud de $SUBG$ qui maximise $|CAND \cap N(u)|$
        \While{$CAND \setminus N(u) \neq \emptyset$}
          \State $p \gets$ un noeud dans $CAND \setminus N(u)$
          \State $ Q \cup p $ \Comment{on ajoute p à $Q$}
          \State // Mise à jour des paramètres
          \State $SUBG_p \gets SUBG \cap N(p)$
          \State $CAND_p \gets CAND \cap N(p)$
          \State \Call{Cliques}{$SUBG_p, CAND_p$}
          \State $CAND \gets CAND \setminus {p}$
          \State $ Q \setminus p $ \Comment{on retire p de $Q$}
        \EndWhile
      \EndIf
    \EndProcedure
    \State \Call{Cliques}{$V,V$}
  \end{algorithmic}
  \caption{\label{fig:cliques} Algorithme CLIQUE}
\end{algorithm}

Plus concrètement, la ligne 5 de l'algorithme, responsable du choix du pivot change pour respecter la propriété ainsi que la condition de sortie de la boucle \emph{while} en ligne 6 et le choix d'un noeud \emph{p} en ligne 7. En effet, nous allons donc explorer des candidats parmi \(\textrm{CAND} \setminus N(u)\).

\subsection{Exemple}%
\label{subsec:ex}

Cette section vous présente un exemple de l'exécution de CLIQUES sur le graphe en Figure \ref{subfig:call1}.
Un code couleur est établi, un noeud entouré de rouge appartient à \texttt{CAND}, colorié en rouge signifie qu'il appartient à \texttt{SUBG}. Un noeud entouré de vert est le noeud pivot de l'appel actuel, entouré de bleu il s'agit du noeud \emph{p} choisi en ligne 7 de l'algorithme \ref{fig:cliques}. Un noeud de forme carrée appartient à la clique courante \emph{Q}.

Nous commençons par le premier appel (voir Figure \ref{subfig:call1}):
\begin{itemize}
  \item \texttt{SUBG} = \texttt{CAND} (en rouge sur la Figure \ref{subfig:call1}) = \(\{1,2,3,4,5,6,7,8,9\}\)
  \item \texttt{Q} est vide
\end{itemize}
Le premier appel se fait avec ces arguments. \texttt{SUBG} n'étant pas vide, nous allons choisir un pivot \emph{u}. Pour rappel, nous cherchons à trouver le noeud dans \texttt{SUBG} tel que l'intersection entre les voisins de ce noeuds et \texttt{CAND} est le plus grand possible. Dans notre exemple il s'agit de 4 (en vert sur la Figure \ref{subfig:call1}).

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.33\textwidth}
      \begin{tikzpicture}
        \node[fill=blue!60, draw=red, ultra thick] (n1) at (0, 5) {1};
        \node[draw=red, fill=red!40, ultra thick] (n2) at (1, 4) {2};
        \node[draw=red, fill=red!40, ultra thick] (n3) at (0, 3) {3};
        \node[draw=green, fill=red!40, ultra thick] (n4) at (1, 2) {4};
        \node[draw=red, fill=red!40, ultra thick] (n5) at (2, 3) {5};
        \node[draw=red, fill=red!40, ultra thick] (n6) at (1, 1) {6};
        \node[draw=red, fill=red!40, ultra thick] (n7) at (-1, 1) {7};
        \node[draw=red, fill=red!40, ultra thick] (n8) at (-1, 2) {8};
        \node[draw=red, fill=red!40, ultra thick] (n9) at (-1, 4) {9};

        \foreach \from/\to in {
          n1/n2, n1/n9,
          n2/n9, n2/n3,
          n3/n9, n3/n4, n3/n8,
          n4/n5, n4/n6, n4/n7, n4/n8,
          n6/n7, n6/n8,
          n7/n8}
        \draw (\from) -- (\to);
      \end{tikzpicture}
      \caption{Premier appel}
      \label{subfig:call1}
    \end{subfigure}
  \begin{subfigure}[b]{0.33\textwidth}
      \begin{tikzpicture}
        \node[rectangle, double] (n1) at (0, 5) {1};
        \node[fill=red!40, draw=red, ultra thick] (n2) at (1, 4) {2};
        \node[] (n3) at (0, 3) {3};
        \node[] (n4) at (1, 2) {4};
        \node[] (n5) at (2, 3) {5};
        \node[] (n6) at (1, 1) {6};
        \node[] (n7) at (-1, 1) {7};
        \node[] (n8) at (-1, 2) {8};
        \node[fill=blue!60, draw=green, ultra thick] (n9) at (-1, 4) {9};

        \foreach \from/\to in {
          n1/n2, n1/n9,
          n2/n9, n2/n3,
          n3/n9, n3/n4, n3/n8,
          n4/n5, n4/n6, n4/n7, n4/n8,
          n6/n7, n6/n8,
          n7/n8}
        \draw (\from) -- (\to);
      \end{tikzpicture}
      \caption{Deuxième appel}
      \label{subfig:call2}
    \end{subfigure}
  \begin{subfigure}[b]{0.33\textwidth}
      \begin{tikzpicture}
        \node[rectangle, double] (n1) at (0, 5) {1};
        \node[fill=blue!60, draw=green, ultra thick] (n2) at (1, 4) {2};
        \node[] (n3) at (0, 3) {3};
        \node[] (n4) at (1, 2) {4};
        \node[] (n5) at (2, 3) {5};
        \node[] (n6) at (1, 1) {6};
        \node[] (n7) at (-1, 1) {7};
        \node[] (n8) at (-1, 2) {8};
        \node[rectangle, double] (n9) at (-1, 4) {9};

        \foreach \from/\to in {
          n1/n2, n1/n9,
          n2/n9, n2/n3,
          n3/n9, n3/n4, n3/n8,
          n4/n5, n4/n6, n4/n7, n4/n8,
          n6/n7, n6/n8,
          n7/n8}
        \draw (\from) -- (\to);
      \end{tikzpicture}
      \caption{Troisième appel}
      \label{subfig:call3}
    \end{subfigure}
  \begin{subfigure}[b]{0.33\textwidth}
      \begin{tikzpicture}
        \node[rectangle, double] (n1) at (0, 5) {1};
        \node[rectangle, double] (n2) at (1, 4) {2};
        \node[] (n3) at (0, 3) {3};
        \node[] (n4) at (1, 2) {4};
        \node[] (n5) at (2, 3) {5};
        \node[] (n6) at (1, 1) {6};
        \node[] (n7) at (-1, 1) {7};
        \node[] (n8) at (-1, 2) {8};
        \node[rectangle, double] (n9) at (-1, 4) {9};

        \foreach \from/\to in {
          n1/n2, n1/n9,
          n2/n9, n2/n3,
          n3/n9, n3/n4, n3/n8,
          n4/n5, n4/n6, n4/n7, n4/n8,
          n6/n7, n6/n8,
          n7/n8}
        \draw (\from) -- (\to);
      \end{tikzpicture}
      \caption{Quatrième appel}
      \label{subfig:call4}
    \end{subfigure}
  \begin{subfigure}[b]{0.33\textwidth}
      \begin{tikzpicture}
        \node[fill=red!40, draw=green, ultra thick] (n1) at (0, 5) {1};
        \node[rectangle] (n2) at (1, 4) {2};
        \node[fill=blue!60, draw=red, ultra thick] (n3) at (0, 3) {3};
        \node[] (n4) at (1, 2) {4};
        \node[] (n5) at (2, 3) {5};
        \node[] (n6) at (1, 1) {6};
        \node[] (n7) at (-1, 1) {7};
        \node[] (n8) at (-1, 2) {8};
        \node[fill=red!40, draw=red, ultra thick] (n9) at (-1, 4) {9};

        \foreach \from/\to in {
          n1/n2, n1/n9,
          n2/n9, n2/n3,
          n3/n9, n3/n4, n3/n8,
          n4/n5, n4/n6, n4/n7, n4/n8,
          n6/n7, n6/n8,
          n7/n8}
        \draw (\from) -- (\to);
      \end{tikzpicture}
      \caption{Cinquième appel}
      \label{subfig:call5}
    \end{subfigure}
      \caption{}
      \label{fig:ex1}
\end{figure}

Conformément à la ligne 6 de CLIQUES, nous allons itérer sur tous les noeuds de \(CAND - N(4)\), c'est-à-dire sur \(\{1, 2, 9, 4\}\).
Prenons \emph{p} = 1.
Nous ajoutons \emph{p} à la clique courante \emph{Q} et nous allons faire un nouvel appel récursif mais avec :
\begin{itemize}
  \item \texttt{SUBG} = \texttt{CAND} = \(SUBG \cap N(1) = CAND \cap N(1) = \{2, 9\}\)
  \item \texttt{Q} = \(\{1\}\)
\end{itemize}

Pour ce deuxième appel (voir \ref{subfig:call2}), \texttt{SUBG} n'est toujours pas vide. Nous choisissons donc un nouveau pivot dans \texttt{SUBG}. Ici \emph{u} = 9. Nous allons itérer dans \(CAND - N(9) = \{9\}\), nous choisissons \emph{p} = 9 (seule possibilité). Nous calculons les nouveaux ensemble \texttt{SUBG} et \texttt{CAND} et ajoutons 9 à \texttt{Q}.

Un troisième appel est effectué avec comme arguments (voir \ref{subfig:call3}) :
\begin{itemize}
  \item \texttt{SUBG} = \texttt{CAND} = \(\{2\}\) (2 étant le seul voisin restant de 9)
  \item \texttt{Q} = \(\{1, 9\}\)
\end{itemize}

Ici le choix du pivot est évident étant donné que nous n'avons qu'un seul candidat. Nous prenons donc \emph{u} = 2. La suite de l'algorithme nous dit d'itérer sur les noeuds dans \texttt{CAND} dont on retire les voisins de \emph{u} (2), ce qui nous laisse que le noeud 2.

Nous choissisons donc \emph{p} = 2 et l'ajoutons à la clique courante \texttt{Q}.
Il est facile de voir que le prochain appel récursif aura pour argument des ensemble vide (excepté \texttt{Q}) dû aux lignes 10 et 11 de CLIQUES.

Nous faisons donc le derniers appel (\ref{subfig:call4}) de l'exploration de cette branche. Nous tombons dans le cas où \texttt{SUBG} est vide et nous avons donc trouvé une clique maximale : \(Q = \{1, 9, 2\}\)

Enfin nous arrivons dans le backtracking et remontons dans l'arbre d'appel (lignes 13 et 14 de CLIQUES). Pour ce faire nous retirons le noeuds \emph{p} mis dans la clique courante mais également de l'ensemble des candidats afin d'éviter de revenir sur un noeuds dont nous avons déjà trouver la clique maximale qui le contient.

Dans notre exemple nous retirons donc le noeuds 2, à ce stade il n'y a pas d'autres noeuds à explorer dans \(CAND - N(u)\) (vide). Nous remontons donc d'un appel et retirons 9 de \texttt{CAND} et \texttt{Q} (Nous obtenons donc \texttt{CAND} = \(\{2\}\) et \texttt{Q} = \(\{1\}\)). Pour rappel il s'agit de l'appel ou 9 est notre pivot \emph{u}. Certe il reste le noeud 2 dans les candidats mais \(CAND - N(u)\) est vide.
L'algorithme continue son backtracking. Nous arrivons dans le premier appel où \emph{u} = 4 et \emph{p} = 1. Nous retirons 1 de \texttt{CAND} ce qui nous donne tous les noeuds sauf 1. Nous continuons donc d'itérer sur \(CAND - N(u)\), c'est-à-dire sur \(\{2, 4, 9\}\). Nous sommes toujours dans la boucle de la ligne 6 de CLIQUES. Un nouveau noeud \emph{p} est désigné : 2. Il est ajouté à la clique courante \emph{Q} (qui était alors vide).

Nous reprenons donc l'exploration en profondeur comme précédemment (\ref{subfig:call5}). Il est important de constater qu'ici, \texttt{SUBG} et \texttt{CAND} sont différent pour l'appel suivant. En effet, le noeud 1 ayant été retiré de \texttt{CAND} (c.f. ligne 13 de CLIQUES), nous avons :

\begin{itemize}
  \item \texttt{SUBG} = \(\{1, 3, 9\}\)
  \item \texttt{CAND} = \(\{3, 9\}\)
\end{itemize}
Le noeud pivot \emph{u} pris ici est 1. Vu que parmi les noeuds de \texttt{SUBG} (1, 3 et 9) il est le seul qui dont \(|CAND \cap N(u)|\) est strictement supérieur à 1 (en effet ici cela laisse un ensemble de cardinalité 2 contrairement à 3 et 9 qui laissent un ensemble de cardinalité 1).

Et comme précédemment nous itérons sur les noeuds dans \(CAND - N(u)\), ici seul 3 réponds au critère. L'algorithme continue ainsi de suite jusqu'à avoir explorer toutes les possiblités.


\section{Implémentation}%
\label{sec:impl}

Les algorithmes présentés précédemment ont été implémenté en \textit{Python} ainsi qu'en \textit{Rust}. Ces deux langages sont relativements différents. \textit{Python} n'est pas un langage typé et permet beaucoup de paradigme. C'est également un langage interprété et non compilé comme \emph{Rust}. Une autre différence majeur est que \emph{Python} est un langage de haut niveau contrairement à \emph{Rust} qui lui est de bas niveau, comparable au \emph{C}. En théorie, nous nous attendons à avoir de meilleur performance en \emph{Rust} qu'en \emph{Python} dû à ces raisons.

Nous aborderons dans les sections \ref{subsec:python} et \ref{subsec:rust} les différences et difficulté d'implémentation des algorithmes ainsi que des challenges spécifiques lié au \emph{Python} et \emph{Rust} respectivement.

Au sujet des graphes, nous avons décider d'utiliser des graphes représenté au format \texttt{g6} (Graph6\cite{g6}). Ce format permet de ne dépendre d'aucune librairie externe pour la manipulation de graphe. Ainsi, peut-importe le langage, il fut implémenter nos propres fonction pour lire et écrire des graphes dans ce format ainsi que notre propre structure de graphe.

\subsection{Python}%
\label{subsec:python}

Comme mentionné précédemment, des fonctions utilitaires ainsi qu'une classe \emph{Graph} ont été développé afin de pouvoir manipuler des graphes. L'objet \emph{Graph} contient deux attributs :
\begin{itemize}
  \item \emph{order} : l'ordre du graphe
  \item \emph{adj} : un dictionnaire d'adjacence
\end{itemize}

Afin de bénéficier d'un accès en \emph{O(2)} aux voisins d'un noeud donné, la liste d'adjacence est un dictionnaire, une structure de donnée de \emph{Python}. Il s'agit d'une liste de paires clé-valeurs. Dans notre cas, une clés est un entier (l'étiquette du noeud) et la valeur associée est une liste d'entier (les voisins du noeuds, celle-ci peut être vide dans le cas où le noeud ne possède aucun voisin).
Une méthodes permettant d'ajouter des noeuds au graphe est également présente.

Les autres fonctions utilitaires sont les fonctions permettant de lire le format g6 et de le traduire dans notre classe \emph{Graph} ainsi que l'opération inverse. Afin que ces fonctions soient efficaces, elles ont été reprise de la libraire \emph{Networkx} pour \emph{Python} qui réalise le même travaille en utilisant le plein potentiel des générateurs de \emph{Python}.

Enfin les différents algorithmes ont été implémenté, chacun dans un fichier. Ceux-ci suivent le pseudo code fourni. Ils utilisent les \emph{sets} de \emph{Python} pour manipuler les ensemble de noeuds efficacement. Dans les arguments des algorithmes, deux on été ajoutés : \emph{result} et \emph{delay}. Il s'agit de deux listes, la première pour stocker la clique maximale une fois celle-ci trouvée et deuxième pour stocker le temps écoulé entre la clique maximale précédente et celle trouvée. Notez que l'impact en performace est quasi nul. En effet ajouter un élément à une liste en \emph{Python} se fait en \emph{O(1)}.

Notez que les algorithmes se ressemblent énormément étant donné qu'ils diffèrent uniquement dans le choix du pivot. Pour la version de Bron-Kerbosch sans pivot, nous itérons simplement sur la liste des candidats.

\subsection{Rust}%
\label{subsec:rust}

L'implémentation en \emph{Rust} des algorithmes fut plus laborieuse dû à une particularité du langage qu'est le principe d'\emph{owrnership}\cite{rust}. Cela implique des changements dans la façon dont fonctionne le code.

Les Figures \ref{fig:p1} et \ref{fig:r1} illustrent la complexité de \emph{Rust} par rapport à \emph{Python}. Afin d'obtenir le même résultat, dû au fonctionnement de \emph{Rust} et à ses mécanismes de vérifications, nous devons nous assurer de la robustesse du code. Par exemple le \verb|.unwrap()| permet de récupérer la valeur de l'appel à \verb|.max_by_key(...)| qui retourne une \emph{Option} (qui pourrait être soit notre résultat, soit \emph{None}). On peut voir également les emprunts (\texttt{\&}) qui permettent d'assurer l'absence de pointeur flottant.

\begin{figure}[ht]
  \begin{lstlisting}[language=Python]
    u = max(SUBG, key=lambda u: len(CAND & G.adj[u]))
  \end{lstlisting}
  \caption{Python : choix du pivot dans CLIQUES}
  \label{fig:p1}
\end{figure}

\begin{figure}[ht]
  \begin{lstlisting}[language=Rust]
    let u = *subg.iter().max_by_key(|&&u| g.adj[&u].iter().filter(|&&neighbor| cand.contains(&neighbor)).count()).unwrap();
  \end{lstlisting}
  \caption{Rust : choix du pivot dans CLIQUES}
  \label{fig:r1}
\end{figure}

Lors de l'implémentation en \emph{Rust} (qui a eu lieu après celle en \emph{Python}), l'objectif a été de rester au plus proche de ce qui était fait en \emph{Python} afin de comparer des implémentations qui \og \textit{font les mêmes choses} \fg{} et ainsi pouvoir constater les différences de performances à armes égales.

Malgré tout, il n'est pas simple de retranscire du \emph{Python} en \emph{Rust} et il est important de noter que dans l'état actuel des implémentations, celle en \emph{Rust} semble moins efficace. Cela est dù à la présence de beaucoup de clonage de sets et vecteurs afin de pouvoir faire fonctionner le code (voir Figure \ref{fig:r2} et \ref{fig:p2}). On peut clairement voir une copie qui semble inutile dans le code \emph{Rust}. Malheureusement cela semble être la meilleure façon de faire car nous devons conserver intact \texttt{SUBG}, \texttt{CAND} et N(p) (\texttt{p\_neighbors} dans le code \emph{Rust})\footnote{Propos appuyés par \href{https://stackoverflow.com/questions/55975234/how-do-i-intersect-two-hashsets-while-moving-values-in-common-into-a-new-set}{ce post StackOverflow}, consulté le 29/07/2024 à 15h30.}
\begin{figure}[ht]
  \begin{lstlisting}[language=Rust]
let subg_p: HashSet<u32> = subg.intersection(&p_neighbors).cloned().collect();
let cand_p: HashSet<u32> = cand.intersection(&p_neighbors).cloned().collect();
  \end{lstlisting}
  \caption{Création des nouveaux ensemble \texttt{SUBG\_p} et \texttt{CAND\_p} en \emph{Rust}}
  \label{fig:r2}
\end{figure}
\begin{figure}[ht]
  \begin{lstlisting}[language=Python]
SUBG_p = SUBG & p_neighbors
CAND_p = CAND & p_neighbors
  \end{lstlisting}
  \caption{Création des nouveaux ensemble \texttt{SUBG\_p} et \texttt{CAND\_p} en \emph{Python}}
  \label{fig:p2}
\end{figure}
\subsection{Limitations}%
\label{subsec:limit}

Initialement, il était prévu de tester les différents algorithmes sur de grands graphes obtenu sur bases de données réelles, dont notamment des graphes représentant les utilistateurs de Deezer et leurs liens (\emph{follow}) (\cite{rozemberczki2020characteristic}), un graphe des relations entre pages de Facebook (\cite{rozemberczki2019multiscale}) par exemples. Mais très vite un soucis c'est posé. En effet il s'agit de très très grand graphes. Par exemple, celui représentant les relations entre pages Facebook contient 22 470 noeuds.

Un simple code en \emph{Python} visant à transformer un de ces graphes au format g6 afin de pouvoir travailler avec fu développer mais celui-ci ne put se terminer. En effet malgré le \emph{hardware} utilisé (voir \ref{subsec:methodo}), la RAM arrivait très vite à saturation résultant en un crash du programme.

Afin de contourner ces limitations deux pistes semblent possible :
\begin{itemize}
  \item Utiliser un autre langage (probablement de bas niveau) afin de réduire le coup sur la mémoire
  \item Augmenter les ressources disponible, surtout la RAM
\end{itemize}

\section{Tests}%
\label{sec:tests}

\subsection{Méthodologie}%
\label{subsec:methodo}
Dans cette section, nous décrivons la méthodologie utilisée pour évaluer les performances de différents algorithmes de détection de cliques maximales sur des graphes de différents ordres. Nous avons implémenté et comparé quatre algorithmes : \texttt{CLIQUES} (\ref{sec:clique}), \texttt{BK} (\ref{subsec:bk}), \texttt{BKP\_R} (\ref{subsec:random}) et \texttt{BKP\_M} (\ref{subsec:max}). Ces algorithmes ont été testés en utilisant tous les graphes d'ordre 4 à 10 inclus. Les graphes utilisés sont disponible au format g6 à ce lien : \url{http://users.cecs.anu.edu.au/~bdm/data/graphs.html}\footnote{Consutlé le 7 juin 2024 à 16h32.}

Pour mesurer le temps d'exécution total des algorithmes, nous avons utilisé la fonction \texttt{time.perf\_counter()} de la bibliothèque \texttt{time} de Python, qui offre une haute précision pour les mesures de temps.

Les données de performance ont été analysées à l'aide de la bibliothèque \texttt{numpy} pour calculer les valeurs moyennes, et les résultats ont été visualisés à l'aide de la bibliothèque \texttt{matplotlib}.

Les expériences ont été exécutées sur une machine équipée d'un processeur AMD Ryzen 7 PRO 5875U et de 32 Go de RAM, garantissant ainsi des performances élevées et une capacité de mémoire suffisante pour traiter des graphes de taille modeste à moyenne.

\subsection{Résultats}%
\label{subsec:res}

Les graphes ci-dessous (Figure \ref{fig:res1}) illustrent le temps d'éxécution moyen des différents algorithmes présentés ici ainsi que le délais moyen entre l'énumération de chaque clique maximale en fonction de l'ordre du graphes. L'ensemble de tests consite en l'entièreté des graphes d'ordre 4 à 10 comme décrit dans la section sur la méthodologie (\ref{subsec:methodo}). Les graphes d'ordres 1 à 3 ont été exclus car l'exécution était tellement rapide qu'aucun temps notable n'était recensé.
\begin{figure}[h!]
    \centering
    \begin{subfigure}[b]{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/total_plot.png}
        \caption{Temps total moyen pour énumérer toutes les cliques maximales}
        \label{fig:total_plot}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/delay_plot.png}
        \caption{Délais moyen pour énumérer une clique maximale}
        \label{fig:delay_plot}
    \end{subfigure}
    \caption{Résultats des temps d'exécution pour différents algorithmes d'énumération des cliques maximales}
    \label{fig:res1}
\end{figure}

Nous pouvons constater en regardant le graphique \ref{fig:total_plot} que, clairement, les différents algorithmes d'énumération de cliques présentés suivent bien une complexité en temps exponetiel par rapport à l'ordre du graphe.

De plus, le graphique \ref{fig:delay_plot} nous montre une temps relativement constant entre l'énumération de chaque clique. Nous pouvons observé un temps moyen pour énumérer les cliques maximales plus élevé pour les graphes d'ordre 4.

En observant les temps obtenu pour les différents algorithmes, nous constatons que \texttt{BKP\_M} (avec pour pivot le noeud de degré maximum) semble se comporter mieux de manière générale.

L'analyse de ces résultats est cohérente avec les discussions théoriques présentées dans l'article \cite{CONTE20221}. L'efficacité des différents algorithmes dépend fortement de leurs approches spécifiques pour traiter les graphes, et la sélection de l'algorithme optimal peut varier en fonction des caractéristiques spécifiques du graphe à traiter.

Afin d'étayer ce dernier propos, nous allons présenter les mêmes tests mais en nous intéressants à des types de graphes particuliers :
\begin{itemize}
  \item Les graphes complets
  \item Les graphes vides
  \item Les graphes de Moon-Moser
\end{itemize}
Pour rappel, les graphes complets d'ordre \emph{n} n'ont qu'une et une seule clique maximales de taille \emph{n}, les graphes vides d'ordre \emph{n} possèdent \emph{n} cliques maximales de taille 1 et enfin, les graphes de Moon-Moser possèdent \(3^{n/3}\) cliques maximales (voir section \ref{subsec:graphes}).

La méthode de test reste la même. L'algorithme sans pivot \texttt{BK} à néansmoins dû être retiré des tests car celui-ci prenait trop de temps d'exécution.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{0.42\textwidth}
    \includegraphics[width=\textwidth]{images/total_pivot_empty_plot.png}
    \caption{Graphes vides}
    \label{subfig:total_empty}
  \end{subfigure}
  \begin{subfigure}[b]{0.42\textwidth}
    \includegraphics[width=\textwidth]{images/total_pivot_turan_plot.png}
    \caption{Graphes de Moon-Moser}
    \label{subfig:total_turan}
  \end{subfigure}
  \caption{Temps d'exécution total pour énumérer toutes les cliques maximales}
  \label{fig:special_total}
\end{figure}

Tout d'abord nous pouvons observer qu'en effet, les différents algorithmes présentés on bien une complexité dans le pire des cas en \(0(3^{n/3})\), cela se voit distinctement sur le graphique \ref{subfig:total_turan} correspondant aux graphes de Moon-Moser, les graphes avec le plus de cliques maximales possibles. Pour ce qui est des graphes vides (\ref{subfig:total_empty}), nous avons quelque chose de très linéaire ce qui s'explique probablement par le fait que vu que chaque noeuds est isolé, énumérer chaque clique maximale consiste à énumérer chaque noeud du graphe. Aucune exploration n'est nécessaire.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{0.42\textwidth}
    \includegraphics[width=\textwidth]{images/delay_pivot_empty_plot.png}
    \caption{Graphes vides}
    \label{subfig:delay_empty}
  \end{subfigure}
  \begin{subfigure}[b]{0.42\textwidth}
    \includegraphics[width=\textwidth]{images/delay_pivot_turan_plot.png}
    \caption{Graphes de Moon-Moser}
    \label{subfig:delay_turan}
  \end{subfigure}
  \caption{Délais entre chaque énumération de clique maximale}
  \label{fig:special_delay}
\end{figure}

Observons maintenant sur ces catégories de graphes ce qu'il en est pour le délais nécessaire pour trouver la prochaine clique maximale. Dans les deux cas nous avons bien un délais qui semble polynomial en fonction du nombre de cliques ce qui est rassurant. Toutefois, il est important de souligner que l'algorithme \texttt{CLIQUES} semble moins efficace et mettre plus de temps que les autres. Cela va à l'encontre des résultats attendu et est probablement dû à l'implémentation réalisée. En effet, trouver le noeud pivot nécessite, pour chaque noeud de \texttt{SUBG} de calculer \(\texttt{CAND} \cap N(u)\) afin de trouver le noeud qui maximise cette propriété, ce qui a un coup plus grand que de trouver le noeud de degré supérieur, cela même ayant un coup plus grand que de tirer un noeud au hasard.

\begin{center}
  \begin{table}[h!]
    \begin{tabular}{|l||l|l|l|l|}
      \hline
      Ordre & BK & BKP\_R & BKP\_M & CLIQUES \\
      \hline
      \hline
      4  & $1.0799^{e-05}$ & $1.6508^{e-05}$ & $1.1213^{e-05}$ & $1.1625^{e-05}$ \\
      5  & $1.2079^{e-05}$ & $1.3219^{e-05}$ & $1.2379^{e-05}$ & $1.3643^{e-05}$ \\
      6  & $1.560e^{e-05}$  & $1.6169^{e-05}$ & $1.5854^{e-05}$  & $1.7883^{e-05}$ \\
      7  & $2.0252^{e-05}$ & $2.0829^{e-05}$ & $1.9958^{e-05}$ & $2.1590^{e-05}$   \\
      8  & $2.5791^{e-05}$ & $2.6625^{e-05}$ & $2.5337^{e-05}$   & $2.7245^{e-05}$ \\
      9  & $3.2806^{e-05}$ & $3.3322^{e-05}$  & $3.189e^{e-05}$  & $3.387e^{e-05}$  \\
      10 & $4.0894^{e-05}$ & $4.1189^{e-05}$ & $3.926e^{e-05}$ & $4.2038^{e-05}$  \\
      \hline
    \end{tabular}
    \caption{Temps d'exécution moyen des algorithmes sur tous les graphes d'ordre donné}
    \label{table:1}
\end{table}
\end{center}
\begin{center}
  \begin{table}[h!]
    \begin{tabular}{|l||l|l|l|l|}
      \hline
      Ordre & BK & BKP\_R & BKP\_M & CLIQUES \\
      \hline
      \hline
      4  & $3.7588^{e-06}$ & $4.0444^{e-06}$ & $4.5968^{e-06}$ & $5.1999^{e-06}$ \\
      5  & $3.0838^{e-06}$ & $3.5742^{e-06}$ & $3.7282^{e-06}$ & $3.9874^{e-06}$ \\
      6  & $2.8786^{e-06}$ & $3.4932^{e-06}$ & $3.4684^{e-06}$ & $3.7294^{e-06}$ \\
      7  & $2.8994^{e-06}$ & $3.4047^{e-06}$ & $3.4149^{e-06}$ & $3.7131^{e-06}$   \\
      8  & $3.0013^{e-06}$ & $3.5007^{e-06}$ & $3.4537^{e-06}$ & $3.7050^{e-06}$ \\
      9  & $3.1184^{e-06}$ & $3.5931^{e-06}$ & $3.5112^{e-06}$ & $3.8213^{e-06}$  \\
      10 & $3.2128^{e-06}$ & $3.6631^{e-06}$ & $3.5805e^{e-06}$ & $3.8666^{e-06}$  \\
      \hline
    \end{tabular}
    \caption{Délais moyen pour énumérer une clique maximale}
    \label{table:2}
\end{table}
\end{center}

\subsubsection*{Comparaison avec \emph{Rust}}

L'une des revendications de ce projet est que, bien implémenté, un algorithme équivalent en \emph{Rust} devrait être plus performant que son homonyme écrit en \emph{Python}. Bien évidemment il va de soit que cela dépend de la qualité de l'implémentation.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/total_pyrust_CLIQUES_plot.png}
  \caption{CLIQUES}%
  \label{subfig:pr_cliques}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/total_pyrust_BK_plot.png}
  \caption{Bron-Kerbosch}%
  \label{subfig:pr_bk}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/total_pyrust_BKP_M_plot.png}
  \caption{BKP\_M}%
  \label{subfig:pr_bkp_m}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/total_pyrust_BKP_R_plot.png}
  \caption{BKP\_R}%
  \label{subfig:pr_bkp_r}
  \end{subfigure}
  \caption{Comparaison des différents algorithmes en \emph{Python} et \emph{Rust}}%
  \label{fig:pvr}
\end{figure}

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/total_CLIQUES_pyrust_pivot_complete_plot.png}
  \caption{Graphes complets}%
  \label{subfig:pr_cliques_complete}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/total_CLIQUES_pyrust_pivot_empty_plot.png}
  \caption{Graphes vides}%
  \label{subfig:pr_cliques_empty}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/total_CLIQUES_pyrust_pivot_turan_plot.png}
  \caption{Graphes de Turàn}%
  \label{subfig:pr_cliques_turan}
  \end{subfigure}
  \caption{Comparaison CLIQUES en \emph{Python} et \emph{Rust} sur des graphes spéciaux}%
  \label{fig:pvr_cliques}
\end{figure}


\section{Conclusion}

% TODO

\bibliographystyle{abbrv}
\bibliography{biblio}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
