\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{algorithm} 
\usepackage{algpseudocode}
\edef\restoreparindent{\parindent=\the\parindent\relax}
\usepackage{parskip}
\restoreparindent
\usepackage{tikz}
\usetikzlibrary{arrows, automata}
\usepackage{subcaption}
\usepackage{graphicx}

\usepackage[export]{adjustbox}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=black,
    urlcolor=teal,
    pdftitle={Rapport de projet de master 1 - Virgil Surin},
    pdfauthor=Virgil Surin,
    pdfpagemode=FullScreen
}

\graphicspath{images/}

\begin{document}
\begin{titlepage}
  \begin{center}

    {\Large Université de Mons}\\[1ex]
    {\Large Faculté des sciences}\\[1ex]
    {\Large Département d'Informatique}\\[2.5cm]

    \newcommand{\HRule}{\rule{\linewidth}{0.3mm}}
    % Title
    \HRule \\[0.3cm]
    { \LARGE \bfseries Étude comparative d'algorithme pour énumérer les cliques maximales d'un graphe \\[0.3cm]}
    { \LARGE \bfseries Rapport préliminaire de projet de Master \\[0.1cm]} % Commenter si pas besoin
    \HRule \\[1.5cm]

    % Author and supervisor
    \begin{minipage}[t]{0.45\textwidth}
      \begin{flushleft} \large
        \emph{Directeur:}\\
        Hadrien \textsc{Mélot}\\
        \emph{Co-directeur:}\\
        Sébastien \textsc{Bonte}\\
      \end{flushleft}
    \end{minipage}
    \begin{minipage}[t]{0.45\textwidth}
      \begin{flushright} \large
        \emph{Auteur:} \\
        Virgil \textsc{Surin}
      \end{flushright}
    \end{minipage}\\[2ex]

    \vfill

    % Bottom of the page
    \begin{center}
      \begin{tabular}[t]{c c c}
        \includegraphics[height=1.5cm]{logoumons.jpg} &
                                                        \hspace{0.3cm} &
                                                                         \includegraphics[height=1.5cm]{logofs.jpg}
      \end{tabular}
    \end{center}~\\

    {\large Année académique 2022-2023}

  \end{center}
\end{titlepage}

\tableofcontents

\newpage

\section{Introduction}


Dans ce rapport nous allons étudier plusieurs algorithmes d'énumeration de cliques maximales dans un graphe simple non orienté. Cette étude ce base sur l'article de Alessio Conte et Etsuji Tomita  \textit{''On the overall and delay complexity of the CLIQUES and Bron-Kerbosch algorithms''}.

L'objectif de ce projet est d'implémenter les algorithmes présentés et de confirmer les résultats obtenu par M.Conte et M.Tomita. Également, ces algorithmes seront implémentés en python et en rust afin de pouvoir comparer leur performance d'un langage à un autre.

Étudier un tel problème et surtout trouver des algorithmes efficaces pour en obtenir la réponse n'est pas sans intérêt. En effet, beaucoup de systèmes peuvent être représentés par des graphes. L'on se rend alors compte que des amats se forment, ce sont là des cliques. Il s'avère que ces cliques peuvent être considérées, selon le système étudié, comme des compartiments indépendant, peut-être des unités logiques. d'où l'utilité des les trouver efficacement. Nous pouvons observer de multiples applications des cliques dans des domaines tels que la biologie, la sociologie et bien d'autres \cite{FORTUNATO201075}.

Nous commencerons par un rappel des notions et notations utilisées ainsi que des définitions utiles à la compréhension de ce rapport, suivi d'une présentation des différents algorithmes implémentés et pour terminer par la comparaison d'efficacité en temps et en langage de ceux-ci.

\section{Les graphes}%
\label{sec:graphes}

\subsection{Notions de bases}

Dans ce rapport, nous allons définir un graphe simple non orienté \emph{G(V, E)} comme étant un ensemble de nœuds \emph{V} reliés par des arêtes. Nous notons l'ensemble des arêtes comme étant l'ensemble \emph{E}. Une arêtes est définie comme un tuple $ (v, v') $ où $ v $ et $ v' $ sont les 2 nœuds réliés par l'arête. Les nœuds peuvent être étiquetés pour plus de lisibilité.

Il y a au plus une et une seule arête entre deux même nœuds et aucune arête allant d'un nœud à lui-même. Les arêtes que nous considérons n'ont pas de sens particulier. Ainsi, l'arête joignant les nœuds \emph{x} et \emph{y} est la même que celle joignant \emph{y} à \emph{x} et sera dénotée par l'existence du tuple $(x, y) \in E$.
Nous notons les voisins d'un nœud \emph{v} par \emph{N(v)}.

Nous définissons l'ordre \emph{m} d'un graphe comme étant $ |V| $ et sa taille \emph{m} comme $ |E| $.

Dans la figure \ref{fig:x exemple1}, nous pouvons observer un premier graphe \textit{a} dont l'ensemble des noeuds \(V\) est l'ensemble \(\{1, 2, 3\}\). L'ensemle des arretes \(E\) quant a lui est l'ensemble \(\{(1,2), (2,3)\}\). Le graphe \textit{a} est un graphe d'ordre 3 et de taille 2. De la meme facon, pour le graphe \textit{b} on a \(V = \{1, 2, 3, 4, 5\}\) et \(E = \{(1,2), (2,3), (4,5)\}\). \textit{b} est d'ordre 5 et de taille 3.

\begin{figure}[h]
  \begin{subfigure}[b]{0.50\textwidth}
    \centering
        \begin{tikzpicture}
          \tikzstyle{vertex}=[circle,fill=black!10]

          \node[vertex](v1) at (0, 0){1};
          \node[vertex](v2) at (0, 2){2};
          \node[vertex](v3) at (2, 2){3};

          \draw[-](v1)--(v2);
          \draw[-](v2)--(v3);

        \end{tikzpicture}
        \caption{}
        \label{fig:x g1}
  \end{subfigure}
  \begin{subfigure}[b]{0.50\textwidth}
    \centering
        \begin{tikzpicture}
          \tikzstyle{vertex}=[circle,fill=black!10]

          \node[vertex](v1) at (0, 0){1};
          \node[vertex](v2) at (1, 2){2};
          \node[vertex](v3) at (3, 2){3};
          \node[vertex](v4) at (2, 0){4};
          \node[vertex](v5) at (4, 1){5};

          \draw[-](v1)--(v2);
          \draw[-](v2)--(v3);
          \draw[-](v4)--(v5);

        \end{tikzpicture}
        \caption{}
        \label{fig:x g2}
  \end{subfigure}
  \caption{Deux graphes (\textit{a} et \textit{b})}
  \label{fig:x exemple1}
\end{figure}


Soit $ W \subseteq V $ et $ E(W) = E \cap (W \times W) $. Nous appellons \emph{SG(W, E(W))} un sous-graphe de \emph{G}.
Par exemple, en prenant le graphe \textit{b} de la figure \ref{fig:x exemple1}, le sous-graphe \(SG(\{1, 2, 5\}, E(\{1, 2, 5\}))\) est un sous-graphe valide de \textit{b} contenant uniquement les noeuds 1, 2 et 5 (\(W\)) et l'arrete \((1,2)\) (\(E(W)\)).

\begin{figure}
  \centering
  \begin{tikzpicture}
    \tikzstyle{vertex}=[circle,fill=black!10]

    \node[vertex](v1) at (0, 0){1};
    \node[vertex](v2) at (1, 2){2};
    \node[vertex](v5) at (4, 1){5};

    \draw[-](v1)--(v2);

  \end{tikzpicture}
  \caption{un sous-graphe de \textit{b}}
\end{figure}

\subsection{Les cliques}%
\label{subsec:cliques}

Une \textit{clique} est définie comme suit :
Soit un graphe \emph{G(V,E)} où \emph{V} est l'ensemble des noeuds de \emph{G} et \emph{E} l'ensemble des arrêtes de \emph{G}. Nous dirons que \(C \subseteq V\), un sous-ensemble de noeuds du graphe, est une clique si et seulement si tous les noeuds de \emph{C} sont voisins entre-eux.
C'est-à-dire :
$$ \forall v, w \in C \ | \ (v, w)\in E \ avec\  v \neq w$$

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \tikzstyle{vertex}=[circle,fill=black!10]

    \node[blue, vertex](v1) at (0, 0){1};
    \node[blue, vertex](v2) at (0, 2){2};
    \node[blue, vertex](v3) at (2, 2){3};
    \node[blue, vertex](v4) at (3, 0){4};
    \node[vertex](v5) at (4, 2){5};
    \node[vertex](v6) at (6, 1.5){6};
    \node[vertex](v7) at (5, 0){7};

    \draw[blue, ultra thick](v1)--(v2);
    \draw[blue, ultra thick](v2)--(v3);
    \draw[blue, ultra thick](v1)--(v3);
    \draw[blue, ultra thick](v1)--(v4);
    \draw[blue, ultra thick](v2)--(v4);
    \draw[blue, ultra thick](v3)--(v4);
    \draw[-](v3)--(v5);
    \draw[-](v4)--(v5);
    \draw[-](v5)--(v6);
    \draw[-](v4)--(v6);
    \draw[-](v4)--(v7);
    \draw[-](v6)--(v7);
  \end{tikzpicture}
  \caption{Un graphe, en bleu une clique de ce graphe}
  \label{fig:x clique1}
\end{figure}

Il est important de remarquer qu'avec cette definition d'une clique, un noeud seul n'est pas une clique.

La \textit{taille} d'une clique est définie par sa cardinalité, c'est à dire que la taille d'une clique \emph{C} est \(|C|\). Comme exemple, prenons la clique en bleu dans le graphe de la figure \ref{fig:x clique1} : nous avons que \(C = {1,2,3,4}\) et \(|C| = 4\). C'est donc une clique de taille 4.

Nous dirons qu'une clique est \textit{maximale} s'il est impossible de rajouter un nœuds de \emph{G} dans la clique tel que la propriété si dessus reste respectée.

Dans la figure \ref{fig:x clique1}, la clique \textit{bleue} composee des noeuds 1, 2, 3 et 4 est egalement maximale. Par contre, la clique composee des noeuds 3 et 5 ne l'est pas car il est possible d'y rajouter le noeud 4.

Enfin, nous définirons une clique \textit{maximum} comme étant la clique de plus grande taille. Notons que toute clique maximum sera maximale et qu'il peut y avoir plusieurs cliques maximum dans un même graphe.

\begin{figure}[h]
  \begin{center}
\begin{tikzpicture}
  \tikzstyle{vertex}=[circle,fill=black!10]

  \node[vertex](v1) at (0, 0){1};
  \node[vertex](v2) at (0, 2){2};
  \node[blue, vertex](v3) at (2, 2){3};
  \node[blue, vertex](v4) at (3, 0){4};
  \node[blue, vertex](v5) at (4, 2){5};
  \node[vertex](v6) at (6, 1){6};
  
  \draw[-](v1)--(v2);
  \draw[-](v2)--(v3);
  \draw[blue, ultra thick](v3)--(v4);
  \draw[blue, ultra thick](v3)--(v5);
  \draw[blue, ultra thick](v4)--(v5);
  \draw[-](v5)--(v6);
\end{tikzpicture}
\caption{Un graphe}
  \label{fig:x clique2}
\end{center}
\end{figure}

Regardons la figure \ref{fig:x clique2}. $ \{3, 4, 5\}$ (en bleu) est une clique maximale et maximum car il n'est pas possible de rajouter un noeud à cette clique tel qu'il sera voisin de 3, 4 et 5 (maximale) et il n'existe pas de clique de plus grande taille (maximum). Par contre, la clique composée des noéuds 1 et 2, bien qu'étant maximale (en effet, aucun autre noeud du graphe ne peut être ajouté à cette clique) n'est pas maximum car elle ne contient que 2 noeuds là où la clique précédemment mentionnée (celle en bleu sur la figure \ref{fig:x clique2}) est plus grande vu qu'elle contient 3 noeuds.

\section{Le problème d'énumération des cliques dans un graphe}
Ce problème consiste, dans un graphe simple, à énumérer toutes les cliques \textbf{maximales} de celui-ci. L'ordre dans lequel celles-ci sont listées n'est pas important.

\begin{figure}[h]
  \begin{center}
    \begin{tikzpicture}
      \tikzstyle{vertex}=[circle,fill=black!10]

      \node[vertex](v1) at (0, 1){1};
      \node[vertex](v2) at (0, 3){2};
      \node[vertex](v3) at (2, 2){3};
      \node[vertex](v4) at (4, 0){4};
      \node[vertex](v5) at (4, 2){5};
      \node[vertex](v6) at (6, 3){6};
      \node[vertex](v7) at (6, 1){7};

      \draw[-](v1)--(v2);
      \draw[-](v1)--(v3);
      \draw[-](v2)--(v3);
      \draw[-](v3)--(v4);
      \draw[-](v3)--(v5);
      \draw[-](v4)--(v5);
      \draw[-](v5)--(v6);
      \draw[-](v5)--(v7);
      \draw[-](v4)--(v7);
      \draw[-](v4)--(v6);
      \draw[-](v6)--(v7);
    \end{tikzpicture}
    \caption{}
    \label{fig:x clique3}
  \end{center}
\end{figure}


Prenons par exemple le graphe en figure \ref{fig:x clique3}. Nous sommes donc intéressé d'obtenir les cliques suivantes :
\begin{itemize}
        \item \(\{1, 2, 3\}\)
        \item \(\{5, 4, 3\}\)
        \item \(\{4, 5, 7, 6\}\)
\end{itemize}
Ces trois cliques sont bien les seules et uniques cliques maximales de ce graphe. De plus, la clique maximum est celles contenant les noeuds 4, 5, 6 et 7.
Notez comme la clique \({4, 5, 6}\) n'est pas reprise, en effet celle-ci n'est pas maximale car elle peut être agrandie avec le noeud 7.

\subsection{Complexité du problème}
Le problème d'énumération de toutes les cliques maximales dans un graphe simple est un problème appartenant à la classe NP-Complet. C'est-à-dire qu'il n'existe pas d'algorithme déterministe en temps polynomial qui permette d'énumérer toutes les cliques maximales d'un graphe.


\section{Algorithmes}

\subsection{CLIQUE}


Cet algorithme se base sur une exploration en profondeur afin d'énumérer toutes les cliques maximales de \emph{G}.
CLIQUE est une procédure récursive. Il introduit un ensemble \emph{Q} vide représentant la clique courante et essaie d'étendre \emph{Q} sur base de deux sous-ensemble de noeuds \textit{SUBG} et \textit{CAND}.

Initialiement, $ SUBG \leftarrow V $ et $ CAND \leftarrow V $. L'objectif est d'énumérer toutes les cliques maximales dans le sous-graphe induit par \emph{SUBG} en étendant la clique courante \emph{Q} avec des noeuds candidats dans \emph{CAND}.

Soit $ Q = \{p_1, p_2, ..., p_d\} $ la clique courante.
Alors $ SUBG = V \cap N(p_1) \cap N(p_2) \cap ... \cap N(p_d)$, c'est à dire l'ensemble des nœuds voisins de tout nœud appartenant à \emph{Q}. L'algorithme selectionne alors  un noeud $ p \in SUBG $ et l'ajoute à \emph{Q} et ceci pour tout nœud dans \emph{SUBG}. Cela egendre un appel récursif avec $ SUBG_p = SUBG \cap N(p) $ et $ CANDp = CAND \cap N(p) $. \emph{p} sera retiré de $ CAND $ après l'exécution de l'appel récursif lors du \textit{backtracking}.

Afin de ne pas engendrer trop d'appel récursif, nous pouvons choisir
inteligemment un noeud \textit{u} qui nous appèlerons le \textit{pivot}. Il existe plusieurs facon de choisir
ce pivot. Conte et Tomita\cite{CONTE20221} décrivent un bon pivot \emph{u} comme étant un noeud de
\emph{SUBG} qui maximise $ | CAND \cap N(u) |$. Un tel pivot va ainsi minimiser $ |CAND \setminus N(u)| $, ce
qui est intéressant car toute clique maximale $ Q' $ dans $ SUBG \cap N(u) $ n'est pas maximale dans
$ G(SUBG) $ car il est possible d'ajouter $ u $ à cette clique. Ainsi, toute clique maximale contien soit
\textit{u} soit un noeud dans $ SUBG \setminus N(u)$. Il n'est donc pas nécessaire d'explorer les voisins de
$ u $ dans ce cas.
Cela explique pourquoi $ u $ est un bon pivot, car maximiser $ | CAND \cap N(u) | $ va minimiser
$ CAND \setminus N(u)$ et donc minimiser le nombre d'appel.

Ci-dessous le pseudo-code de l'algorithme décrit précédement.
\begin{algorithm}[H]
  \textbf{Input}: un graphe $G = (V,E)$

  \textbf{Output}: toutes les cliques maximales de $G$
  \begin{algorithmic}[1]
    \Procedure{CLIQUES}{$SUBG, CAND$}
      \If{$SUBG = \emptyset$} \Comment{$Q$ est une clique maximale}
        \State \textbf{print} ($ Q $)
      \Else
        \State $u \gets$ un noeud de $SUBG$ qui maximise $|CAND \cap N(u)|$
        \While{$CAND \setminus N(u) \neq \emptyset$}
          \State $p \gets$ un noeud dans $CAND \setminus N(u)$
          \State $ Q \cup p $ \Comment{on ajoute p à $Q$}
          \State // Mise à jour des paramètres
          \State $SUBG_p \gets SUBG \cap N(p)$
          \State $CAND_p \gets CAND \cap N(p)$
          \State \Call{Cliques}{$SUBG_p, CAND_p$}
          \State $CAND \gets CAND \setminus {p}$
          \State $ Q \setminus p $ \Comment{on retire p de $Q$}
        \EndWhile
      \EndIf
    \EndProcedure
    \State \Call{Cliques}{$V,V$}
  \end{algorithmic}
  \caption{\label{fig:cliques} Algorithme CLIQUE}
\end{algorithm}

La complexité dans le pire des cas de CLIQUES est en $ O(3^{n/3}) $\cite{CONTE20221}.

Une implémentation de l'algorithme CLIQUE est disponible en python ainsi que des variantes avec d'autres pivots également présentés dans l'article.

\section{Plannification}%
\label{sec:plan}

Une implémentation du code en python est déjà fournie et à l'avenir, une implémentation en Rust sera faite afin de pouvoir comparer l'exécution d'un même algorithme sur deux langages différents. En parlant de comparaison, des tests de performances sur les différents algorithmes présenter dans l'article sera réalisé afin de confirmer les résultats des auteurs de l'article en question.

D'un point de vue rédaction, il faut développer la description des différents algorithmes (et surtout tous les explicités) ainsi que de présenter les sets de données qui servironts aux tests et la méthodologie. Ceci incluant une description du matériel utilisé mais aussi la façon dont les performances vont être mesurées.



% \section{Tests}%
% \label{sec:tests}
% Cette section est dédiée aux tests de performances réalisé dans le cadre de ce projet. Les différents elgorithmes testés sont les suivants

% \subsection{Méthodologie}%
% \label{subsec:methodo}
% Explication de la méthodo pour les temps

% \subsection{Tests sets}%
% \label{subsec:sets}

% Explications des différents input de tests.


% \section{Conclusion}

% TODO

\bibliographystyle{apalike}
\bibliography{biblio}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
