\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{algorithm} 
\usepackage{algpseudocode}
\usepackage{tikz}
\usetikzlibrary{arrows, automata}
\usepackage{subcaption}
\usepackage{graphicx}

\usepackage[export]{adjustbox}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=blue,
    urlcolor=blue
}

\graphicspath{images/}

\begin{document}
\begin{titlepage}
\begin{center}

{\Large Université de Mons}\\[1ex]
{\Large Faculté des sciences}\\[1ex]
{\Large Département d'Informatique}\\[2.5cm]

\newcommand{\HRule}{\rule{\linewidth}{0.3mm}}
% Title
\HRule \\[0.3cm]
{ \LARGE \bfseries Étude comparative d'algorithme pour énumérer les cliques maximales d'un graphe \\[0.3cm]}
{ \LARGE \bfseries Rapport préliminaire de projet de Master \\[0.1cm]} % Commenter si pas besoin
\HRule \\[1.5cm]

% Author and supervisor
\begin{minipage}[t]{0.45\textwidth}
\begin{flushleft} \large
\emph{Directeur:}\\
Hadrien \textsc{Mélot}\\
\emph{Co-directeur:}\\
Sébastien \textsc{Bonte}\\
\end{flushleft}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\begin{flushright} \large
\emph{Auteur:} \\
Virgil \textsc{Surin}
\end{flushright}
\end{minipage}\\[2ex]

\vfill

% Bottom of the page
\begin{center}
\begin{tabular}[t]{c c c}
\includegraphics[height=1.5cm]{logoumons.jpg} &
\hspace{0.3cm} &
\includegraphics[height=1.5cm]{logofs.jpg}
\end{tabular}
\end{center}~\\
 
{\large Année académique 2022-2023}

\end{center}
\end{titlepage}

\tableofcontents

\newpage

\section{Introduction}

Dans ce rapport nous allons étudier plusieurs algorithme d'énumeration de cliques maximales dans un graphe simple non orienté. Cette étude ce base sur l'article de Alessio Conte et Etsuji Tomita  \textit{''On the overall and delay complexity of the CLIQUES and Bron-Kerbosch algorithms''}. \\
L'objectif de ce projet est d'implémenter les algorithmes présentés et de confirmer les résultats obtenu par M.Conte et M.Tomita. \\

Nous commencerons par un rappel des notions et notations utilisées, suivi d'une présentation des différents algorithmes implémenter pour terminer par la comparaison d'efficacité en temps de ceux-ci.

\subsection{Quelques notions de bases} 

Dans ce rapport, nous allons définir un graphe simple non orienté \emph{G(V, E)} comme étant un ensemble de nœuds \emph{V} reliés par des arêtes. Nous notons l'ensemble des arêtes comme étant l'ensemble \emph{E}. Une arêtes est définie comme un tuple $ (v, v') $ où $ v $ et $ v' $ sont les 2 nœuds réliés par l'arête. Les nœuds peuvent être étiquetés pour plus de lisibilité. \\

Il y a au plus une et une seule arête entre deux même nœuds et aucune arête allant d'un nœud à lui-même. Les arêtes que nous considérons n'ont pas de sens particulier. Ainsi, l'arête joignant les nœuds \emph{x} et \emph{y} est la même que celle joignant \emph{y} à \emph{x} et sera dénotée par l'existence du tuple $(x, y) \in E$.
Nous notons les voisins d'un nœud \emph{v} par \emph{N(v)}.\\ 

Nous définissons l'ordre \emph{m} d'un graphe comme étant $ |V| $ et sa taille \emph{m} comme $ |E| $. \\

Soit $ W \subseteq V $ et $ E(W) = E \cap (W \times W) $. Nous appellons \emph{SG(W, E(W))} un sous-graphe de \emph{G}.

\subsection{Définition d'une \textit{clique}}

Une \textit{clique} \emph{C} est un sous-ensemble de nœuds de $ V $ tel que tous les nœuds de $ C $ sont voisins entre-eux. C'est-à-dire :
$$ \forall v, w \in C | (v, w)\in V \ avec\  v \neq w$$

Nous dirons qu'une clique est \textit{maximale} s'il est impossible de rajouter un nœuds de \emph{G} dans la clique tel que la propriété si dessus reste respectée.

Enfin, nous définirons une clique \textit{maximum} comme étant la clique de plus grande cardinalité, c'est à dire contenant le plus de noeuds. Notons que toute clique maximum sera maximale et qu'il peut y avoir plusieurs cliques maximum dans un même graphe.

\begin{figure}[h]
  \begin{center}
\begin{tikzpicture}
  \tikzstyle{vertex}=[circle,fill=black!10]

  \node[vertex](v1) at (0, 0){1};
  \node[vertex](v2) at (0, 2){2};
  \node[vertex](v3) at (2, 2){3};
  \node[vertex](v4) at (3, 0){4};
  \node[vertex](v5) at (4, 2){5};
  \node[vertex](v6) at (6, 1){6};
  
  \draw[-](v1)--(v2);
  \draw[-](v2)--(v3);
  \draw[-](v3)--(v4);
  \draw[-](v3)--(v5);
  \draw[-](v4)--(v5);
  \draw[-](v5)--(v6);
\end{tikzpicture}
\caption{Un graphe}
  \label{fig:x example graph}
\end{center}
\end{figure}

Dans le graphe \ref{fig:x example graph}, l'ensemble $ \{3, 4\} $ est une clique non maximale car il est possible d'y ajouter le noeud $ 5 $, celui-ci étant voisin de $ 3 $ et de $ 4 $.

$ \{3, 4, 5\}$ est une clique maximale et maximum car il n'est pas possible de rajouter un noeud à cette clique tel qu'il sera voisin de 3, 4 et 5 (maximale) et il n'existe pas de clique de plus grande taille (maximum).


\section{Algorithmes}

\subsection{CLIQUES}


Cet algorithme se base sur une exploration en profondeur afin d'énumérer toutes les cliques maximales de \emph{G}.
CLIQUE est une procédure récursive. Il introduit un ensemble \emph{Q} vide représentant la clique courante et essaie d'étendre \emph{Q} sur base de deux sous-ensemble de noeuds \textit{SUBG} et \textit{CAND}.\\

Initialiement, $ SUBG \leftarrow V $ et $ CAND \leftarrow V $. L'objectif est d'énumérer toutes les cliques maximales dans le sous-graphe induit par \emph{SUBG} en étendant la clique courante \emph{Q} avec des noeuds candidats dans \emph{CAND}. \\

Soit $ Q = \{p_1, p_2, ..., p_d\} $ la clique courante.
Alors $ SUBG = V \cap N(p_1) \cap N(p_2) \cap ... \cap N(p_d)$, c'est à dire l'ensemble des nœuds voisins de tout
nœud appartenant à \emph{Q}. L'algorithme selectionne alors  un noeud $ p \in SUBG $ et l'ajoute à \emph{Q} et
ceci pour tout nœud dans \emph{SUBG}. Cela egendre un appel récursif avec $ SUBG_p = SUBG \cap N(p) $ et $ CANDp = CAND \cap N(p) $. \emph{p} sera retiré de $ CAND $ après l'exécution de l'appel récursif lors du \textit{backtracking}. \\


Afin de ne pas engendrer trop d'appel récursif, nous pouvons choisir
inteligemment un noeud \textit{u} qui nous appèlerons le \textit{pivot}. Il existe plusieurs facon de choisir
ce pivot. Conte et Tomita\cite{contetomita} décrivent un bon pivot \emph{u} comme étant un noeud de
\emph{SUBG} qui maximise $ | CAND \cap N(u) |$. Un tel pivot va ainsi minimiser $ |CAND \setminus N(u)| $, ce
qui est intéressant car toute clique maximale $ Q' $ dans $ SUBG \cap N(u) $ n'est pas maximale dans
$ G(SUBG) $ car il est possible d'ajouter $ u $ à cette clique. Ainsi, toute clique maximale contien soit
\textit{u} soit un noeud dans $ SUBG \setminus N(u)$. Il n'est donc pas nécessaire d'explorer les voisins de
$ u $ dans ce cas. \\
Cela explique pourquoi $ u $ est un bon pivot, car maximiser $ | CAND \cap N(u) | $ va minimiser
$ CAND \setminus N(u)$ et donc minimiser le nombre d'appel.


Ci-dessous le pseudo-code de l'algorithme décrit précédement.
\begin{algorithm}
  \caption{CLIQUES}
  \textbf{Input}: un graphe $G = (V,E)$\\
  \textbf{Output}: toutes les cliques maximales de $G$
  \begin{algorithmic}[1]
    \Procedure{CLIQUES}{$SUBG, CAND$}
      \If{$SUBG = \emptyset$} \Comment{$Q$ est une clique maximale}
        \State \textbf{print} ($ Q $)
      \Else
        \State $u \gets$ un noeud de $SUBG$ qui maximise $|CAND \cap N(u)|$
        \While{$CAND \setminus N(u) \neq \emptyset$}
          \State $p \gets$ un noeud dans $CAND \setminus N(u)$
          \State $ Q \cup p $ \Comment{on ajoute p à $Q$}
          \State // Mise à jour des paramètres
          \State $SUBG_p \gets SUBG \cap N(p)$
          \State $CAND_p \gets CAND \cap N(p)$
          \State \Call{Cliques}{$SUBG_p, CAND_p$}
          \State $CAND \gets CAND \setminus {p}$
          \State $ Q \setminus p $ \Comment{on retire p de $Q$}
        \EndWhile
      \EndIf
    \EndProcedure
    \State \Call{Cliques}{$V,V$}
  \end{algorithmic}
\end{algorithm}

La complexité dans le pire des cas de CLIQUES est en $ O(3^{n/3}) $\cite{contetomita}.

\section{DOMTutor -Système de vérification}

Afin de pouvoir tester le plus exhaustivement possible l'exactitude des algorithmes qui vont être implémenter lors de ce projet, j'ai adapté le système \textbf{DOMtutor}\cite{domtutor}, étant lui-même une adaptation de \textbf{DOMjudge}\cite{domjudge}.

DOMtutor est un système utilisé lors de concours d'algorithmie et permet à des équipes de soumettre un code qui a pour but de résoudre un problème donné. Ce code sera ensuite lancé sur plusieurs \textit{test cases} écrit au préalable par un jury. DOMtutor comparera ensuite la réponse du code soumis avec les réponses données par les codes fournis par les jury. \\

Dans le cadre de l'énumération des cliques maximales dans un graph, j'ai pris comme \textit{test cases} l'ensemble de tout les graphes d'ordre 6 au format g6. Comme code \textit{solution}, j'ai utilisé la librairie \textit{NetworkX} afin d'énumérer toutes les cliques maximales.

L'avantage de ce système est qu'il peut tourner sur un serveur ce qui permet de bénéficier de plus de puissance. Ici j'ai fourni dans le .zip l'ensemble du système afin de le faire tourner en local.
% TODO finish this

\section{Conclusion}

% TODO

\newpage
\begin{thebibliography}{unsrt}
\bibitem{contetomita} Alessio Conte et Etsuji Tomita :  \textit{"On the overall and delay complexity of the CLIQUES and Bron-Kerbosch algorithms"} -  12/11/2021
\bibitem{domtutor} \url{https://www.domjudge.org/} par Jaap Eldering, Nicky Gerritsen, Keith Johnson, Thijs Kinkhorst, Mart Pluijmaekers, Michael Vasseur and Tobias Werth - consulté le 30/12/2022 à 17h05
\bibitem{domjudge} \url{https://github.com/DOMtutor} par Tobias Meggendorfer - consulté le 30/12/2022 à 17h10
\bibitem{networkx} \url{https://networkx.org} - consulté le 30/12/2022 à 17h15
\end{thebibliography}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
